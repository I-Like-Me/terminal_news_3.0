{% extends "base.html" %}

{% block content %}

<div id="container">
  <div id="leftPanel">
    <button id="toggleBtn" onclick="toggleFileTreeSearch()">Search</button>
    <div id="fileTreeContainer">
      <div id="fileTree" class="root-folder"></div>
    </div>
    <div id="searchContainer">
      <input type="text" id="searchInput" placeholder="Search..." onkeyup="handleKeyUp(event)">
      <button onclick="runSearch()">Search</button>
      <ul id="searchResults" onclick="handleSearchResultClick(event)"></ul>
    </div>
  </div>

  <div id="separator"></div>

  <div id="rightPanel">
    <div id="file_buttons" class="row" style="display: none;">
        <div class="column">
            <button id="saveBtn">Save</button>
            <button onclick="showInputField('move', event)">Move File</button>
            <button id="deleteBtn" style="background-color: red;" onclick="showInputField('delete_file', event)">Delete File</button>
        </div>
    </div>
    <div id="folder_buttons" class="row" style="display: none;">
        <div class="column">
            <button onclick="showInputField('folder', event)">Add Folder</button>
            <button onclick="showInputField('file', event)">Add File</button>
            <button onclick="showInputField('move', event)">Move Folder</button>
            <button style="background-color: red;" onclick="showInputField('delete_folder', event)">Delete Folder</button>
        </div>   
    </div>
    <div id="toolbar" style="display: none;">
      <div class="row"> 
        <div class="col">
          <!-- Add a series of dropdowns for headers -->
          <select class="ql-header">
            <option value="" selected></option>
            <option value="1">Header 1</option>
            <option value="2">Header 2</option>
            <option value="3">Header 3</option>
          </select>

          <!-- Add styling buttons -->
          <button class="ql-bold"></button>
          <button class="ql-italic"></button>
          <button class="ql-underline"></button>
      
          <!-- Add list buttons -->
          <button class="ql-list" value="ordered"></button>
          <button class="ql-list" value="bullet"></button>
      
          <!-- Add clean button -->
          <button class="ql-clean"></button>
          
          <!-- Add link button -->
          <button id='custom-link-button'><i class="fa fa-link"></i></button>
        </div>
        <div class="col">
          <div id='linkDropdownDiv'></div>
        </div>
      </div>     
    </div>    
    <div id="editorContainer"></div> 
  </div>
</div>

<script>
cur_user = '{{ user_name }}'
let fileTreeData;
const fileTreeElement = document.getElementById('fileTree');
window.onload = function() {
  var username = cur_user; 
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
      fileTreeData = JSON.parse(this.responseText);
      createFileTree(fileTreeData, fileTreeElement);
    }
  };
  xhttp.open("GET", "/get_cabinet/" + username, true);
  xhttp.send();
}

function createFileTree(node, parentElement, isFirstLayer = true, newItemName = null) {
  const listItem = document.createElement('li');
  listItem.innerHTML = `<div class="${node.type === 'folder' ? 'folder' : 'file'}" data-name="${node.name}"><span class="arrow">${node.type === 'folder' ? '<i class="bi bi-caret-right-fill"></i>' : ''}</span>${node.name}</div>`;

  if (node.children) {
    const childList = document.createElement('ul');
    if (!isFirstLayer) {
      childList.style.display = 'none';
    }
    node.children.forEach(childNode => createFileTree(childNode, childList, false, newItemName));
    listItem.appendChild(childList);

    if (node.type === 'folder') {
      const arrowElement = listItem.querySelector('.arrow');
      arrowElement.addEventListener('click', (event) => {
        event.stopPropagation();
        childList.style.display = childList.style.display === 'none' ? 'block' : 'none';
        arrowElement.innerHTML = arrowElement.innerHTML === '<i class="bi bi-caret-right-fill"></i>' ? '<i class="bi bi-caret-down-fill"></i>' : '<i class="bi bi-caret-right-fill"></i>';
      });

      if (isFirstLayer || node.name === newItemName) {
        childList.style.display = 'block';
        arrowElement.innerHTML = '<i class="bi bi-caret-down-fill"></i>';
      }
    }
  }

  if (node.name === newItemName) {
    listItem.querySelector(`div[data-name="${newItemName}"]`).classList.add('highlight');
  }
  parentElement.appendChild(listItem);
}


function toggleFileTreeSearch() {
  const fileTreeContainer = document.getElementById('fileTreeContainer');
  const searchContainer = document.getElementById('searchContainer');
  const toggleBtn = document.getElementById('toggleBtn');

  if (fileTreeContainer.style.display !== 'none') {
    fileTreeContainer.style.display = 'none';
    searchContainer.style.display = 'block';
    toggleBtn.textContent = 'File Tree';
  } else {
    fileTreeContainer.style.display = 'block';
    searchContainer.style.display = 'none';
    toggleBtn.textContent = 'Search';
  }
}

function handleKeyUp(event) {
  if (event.keyCode === 13) {
    runSearch();
  }
}

function runSearch() {
  const searchInput = document.getElementById('searchInput').value.toLowerCase();
  const searchResults = document.getElementById('searchResults');
  searchResults.innerHTML = '';

  if (searchInput.length === 0) {
    return;
  }
  function searchInTree(node, path) {
    const matches = [];
    const nodeName = node.name.toLowerCase();
    if (nodeName.includes(searchInput)) {
      matches.push({ path, confidence: 5 });
    }
    if (node.children) {
      node.children.forEach((child, index) => {
        const childPath = path ? `${path} > ${child.name}` : child.name;
        matches.push(...searchInTree(child, childPath));
      });
    }
    return matches;
  }
  const searchResultsData = searchInTree(fileTreeData, '');
  const sortedResults = searchResultsData.sort((a, b) => b.confidence - a.confidence);
  sortedResults.slice(0, 5).forEach(result => {
    const listItem = document.createElement('li');
    listItem.textContent = result.path;
    listItem.addEventListener('click', () => handleSearchResultClick(result.path));
    searchResults.appendChild(listItem);
  });
}

function handleSearchResultClick(path) {
  const fileTreeContainer = document.getElementById('fileTreeContainer');
  const searchContainer = document.getElementById('searchContainer');
  const toggleBtn = document.getElementById('toggleBtn');
  const pathArray = path.split(' > ');
  const lastNodeName = pathArray.pop(); 
  let currentNode = fileTreeData;
  let currentElement = fileTreeElement;
  const allFolders = fileTreeElement.querySelectorAll('.folder');
  allFolders.forEach(folder => {
    
    if (folder.parentElement.parentElement.id !== 'fileTree') {
      folder.nextElementSibling.style.display = 'none';
      folder.classList.remove('open');
    }
  });

  pathArray.forEach(name => {
    const child = currentNode.children.find(node => node.name === name);
    if (child) {
      currentNode = child;
      const element = currentElement.querySelector(`[data-name="${currentNode.name}"]`);
      if (element) {
        if (currentNode.type === 'folder' && !element.classList.contains('open')) {
          element.classList.add('open');
          element.nextElementSibling.style.display = 'block';
        }
        currentElement = element.nextElementSibling;
      }
    }
  });

  const lastElement = currentElement.querySelector(`[data-name="${lastNodeName}"]`);
  if (lastElement) {
    lastElement.classList.add('highlight');
  }
  const element = currentElement.querySelector(`[data-name="${lastNodeName}"]`);
  if (element) {
    const container = fileTreeContainer.querySelector('ul');
    container.scrollTop = element.offsetTop - container.offsetTop;
  }
  fileTreeContainer.style.display = 'block';
  searchContainer.style.display = 'none';
  toggleBtn.textContent = 'Search';
}

let selectedItem;
let selectedItemName;
let selectedItemType;
let selectedItemContent;
let newItemName;
let newItemType;
let selectedElement; 
let itemPath;
let parentPath;
let parentItemName;
let actionType;
const affectedFileList = [];
const changeFileList = [];
let allFileList = [];
let moveMode = false;
let destinationFolder;
let previousState = {};
let sourcePath;
let destinationPath;


function fileButtonsVis() {
    document.getElementById('file_buttons').style.display = 'block';
    document.getElementById('folder_buttons').style.display = 'none';
}

function folderButtonsVis() {
    document.getElementById('file_buttons').style.display = 'none';
    document.getElementById('folder_buttons').style.display = 'block';
}

function allButtonsOff() {
    document.getElementById('file_buttons').style.display = 'none';
    document.getElementById('folder_buttons').style.display = 'none';
}

fileTreeElement.addEventListener('click', (event) => {
  if (moveMode) {
    event.stopPropagation();
    const newDestinationFolder = event.target.closest('.folder');
    if (newDestinationFolder) {
      // If there was a previously selected destination folder, remove the highlight
      if (destinationFolder) {
        destinationFolder.classList.remove('highlight');
      }
      // Add the highlight to the newly selected destination folder
      newDestinationFolder.classList.add('highlight');
      // Update the destinationFolder variable
      destinationFolder = newDestinationFolder;
      const confirmButton = document.querySelector('.moveConfirm button');
      confirmButton.disabled = false;
      const message = document.querySelector('.moveConfirm p');
      message.textContent = 'Are you sure you want to move this item?';
    }
    return;
  }
  const target = event.target;
  const fileTypeElement = target.closest('.file');
  const folderTypeElement = target.closest('.folder');
  const allItems = fileTreeElement.querySelectorAll('.file, .folder');
  allItems.forEach(item => {
    item.classList.remove('highlight');
  });

  if (fileTypeElement) {
    if (moveMode) {
      return;
    }
    const fileName = fileTypeElement.getAttribute('data-name');
    const filePath = getItemPath(fileTypeElement);
    const fileData = findFileData(fileTreeData, filePath, '');
    fileTypeElement.classList.add('highlight');
    selectedElement = fileTypeElement;
    if (selectedElement) {
      selectedItemName = selectedElement.getAttribute('type');
    }
    selectedItemName = fileName;
    selectedItemType = fileData.type;
    selectedItemContent = fileData.content
    if (fileData && fileData.content) {
      fetch('/process_file_content', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ content: fileData.content })
      })
      .then(response => response.json())
      .then(data => {
        displayTextInRightPanel(data.processed_content, fileData.content);
        toolbar = document.getElementById('toolbar');
        toolbar.style.display = 'block';
      });
      fileButtonsVis();
    }
  } else if (folderTypeElement) {
    if (moveMode) {
      destinationFolder = folderTypeElement;
      destinationFolder.classList.add('highlight');  // Highlight the destination folder
      const confirmButton = document.querySelector('.moveConfirm button');
      confirmButton.disabled = false;
      return;
    }
    const folderName = folderTypeElement.getAttribute('data-name');
    const folderPath = getItemPath(folderTypeElement);
    folderTypeElement.classList.add('highlight');
    selectedElement = folderTypeElement;
    if (selectedElement) {
      selectedItemName = selectedElement.getAttribute('data-name');
    }
    selectedItemName = folderName;
    selectedItemType = 'folder';
    selectedItemContent = 'Not File'
    folderButtonsVis();
    selectedItem = selectedElement;
    const editorContainer = document.getElementById('editorContainer');
    editorContainer.innerHTML = '';
  } else {
    folderButtonsVis();
  }
});

function showInputField(type, event) {
  newItemType = type;
  const rightPanel = document.getElementById('rightPanel');
  
  const existingConfirmWindow = rightPanel.querySelector('.addConfirm, .deleteConfirm, .moveConfirm');
  if (existingConfirmWindow) {
    existingConfirmWindow.remove();
  }

  const confirmWindow = document.createElement('div');
  confirmWindow.className = type === 'folder' || type === 'file' ? 'addConfirm' : type.includes('delete') ? 'deleteConfirm' : 'moveConfirm';
  confirmWindow.innerHTML = `
    <p>${type === 'move' ? 'Click a destination folder from the tree' : 'Are you sure you want to ' + (type.includes('delete') ? 'delete' : 'add') + ' this item?'}</p>
    ${type === 'folder' || type === 'file' ? '<input type="text" id="newItemText" placeholder="Enter item name here.">' : ''}
    <button onclick="${type.includes('delete') ? 'deleteItem()' : type === 'move' ? 'moveItem()' : 'confirmNewItem(event)'}">${type === 'move' ? 'Move' : 'Confirm'}</button>
    <button onclick="cancelAction()">Cancel</button>
  `;
  rightPanel.appendChild(confirmWindow);
  document.addEventListener('click', function onClickOutside(event) {
    if (!confirmWindow.contains(event.target)) {
      if (!fileTreeElement.contains(event.target)) {
        cancelAction();
      }
      confirmWindow.remove();
      document.removeEventListener('click', onClickOutside);
    }
  });
  if (event) {
    event.stopPropagation();
  }

  if (type === 'move') {
    moveMode = true;
    const allFiles = fileTreeElement.querySelectorAll('.file');
    allFiles.forEach(file => {
      file.style.pointerEvents = 'none';
      file.style.opacity = '0.4';
    });

    if (selectedElement.classList.contains('folder')) {
      const folderPath = getItemPath(selectedElement);
      const allFolders = fileTreeElement.querySelectorAll('.folder');
      allFolders.forEach(folder => {
        const folderPathToCheck = getItemPath(folder);
        if (folderPathToCheck.startsWith(folderPath)) {
          folder.style.pointerEvents = 'none';
          folder.style.opacity = '0.4';
        }
      });
    }

    const confirmButton = document.querySelector('.moveConfirm button');
    confirmButton.disabled = true;
    selectedElement.classList.add('highlight');

    previousState = {
      moveMode,
      allFiles,
      selectedElement,
      allFolders: selectedElement.classList.contains('folder') ? fileTreeElement.querySelectorAll('.folder') : null
    };
  }
}

async function moveItem() {
  if (!destinationFolder) {
    alert('No destination folder selected. Please click a destination folder from the tree.');
    return;
  }
  moveMode = false;
  const allFiles = fileTreeElement.querySelectorAll('.file');
  allFiles.forEach(file => {
    file.style.pointerEvents = 'auto';
    file.style.opacity = '1';
  });
  sourcePath = getItemPath(selectedElement);
  destinationPath = getItemPath(destinationFolder);
  newItemName = 'None';
  newItemType = 'None';
  itemPath = 'None';
  parentPath = 'None';
  parentItemName = 'None';
  actionType = 'move';
  affectedFileList.length = 0;
  changeFileList.length = 0
  let currentNode = fileTreeData;
  for (let i = 0; i < sourcePath.length; i++) {
    const child = currentNode.children.find(node => node.name === sourcePath[i]);
    if (child) {
      currentNode = child;
    }
  }
  allFileList = [];
  getAllFiles(fileTreeData);

  await updateJsonFile();
  document.querySelector('.moveConfirm').remove();
  const confirmButton = document.querySelector('.moveConfirm button');
  selectedElement.classList.remove('highlight');  // Remove the highlight from the original selection
  destinationFolder.classList.remove('highlight');  // Remove the highlight from the destination folder
  confirmButton.disabled = false;  // Enable the button
  confirmButton.textContent = 'Confirm';  // Change the button text
  const message = document.querySelector('.moveConfirm p');
  message.textContent = 'Confirm your selection';  // Change the message
}

function cancelAction() {
  // Reset UI state
  const allFiles = fileTreeElement.querySelectorAll('.file');
  allFiles.forEach(file => {
    file.style.pointerEvents = 'auto';
    file.style.opacity = '1';
  });

  if (previousState.allFolders) {
    previousState.allFolders.forEach(folder => {
      folder.style.pointerEvents = 'auto';
      folder.style.opacity = '1';
    });
  }

  if (destinationFolder) {
    destinationFolder.classList.remove('highlight');
    destinationFolder = null;
  }

  if (selectedElement) {
    selectedElement.classList.remove('highlight');
    selectedElement = null;
  }

  // Remove the confirm window
  const confirmWindow = document.querySelector('.addConfirm, .deleteConfirm, .moveConfirm');
  if (confirmWindow) {
    moveMode = false;
    confirmWindow.remove();
  }

  allButtonsOff();
  const editorContainer = document.getElementById('editorContainer');
  editorContainer.innerHTML = '';
}

document.addEventListener('click', function(event) {
  // Check if the move action is running
  if (moveMode) {
    // Check if the click was outside the popup window
    if (!document.querySelector('.moveConfirm').contains(event.target)) {
      // Call the cancelMove function
      
      cancelAction();
    }
  }
});

function findNodeInTree(node, pathArray) {
  if (pathArray.length === 0) {
    return node;
  }
  const nextNodeName = pathArray.shift();
  const nextNode = node.children.find(child => child.name === nextNodeName);
  if (nextNode) {
    return findNodeInTree(nextNode, pathArray);
  }
  return null;
}

function findParentNodeInTree(node, pathArray, parentNode = null) {
  if (pathArray.length === 0) {
    return parentNode;
  }
  const nextNodeName = pathArray.shift();
  const nextNode = node.children.find(child => child.name === nextNodeName);
  if (nextNode) {
    return findParentNodeInTree(nextNode, pathArray, node);
  }
  return null;
}

async function confirmNewItem(event) {
  event.stopPropagation();
  let newItem;
  newItemName = document.getElementById('newItemText').value;
  if (newItemType === 'folder' && document.getElementById('newItemText').style.display !== 'none') {
    newItem = { name: newItemName, type: newItemType, children: [] };
  } else if (newItemType === 'file' && document.getElementById('newItemText').style.display !== 'none') {
    newItem = { name: newItemName, type: newItemType, content: 'Type Here' };
  }
  if (!newItemName) {
    alert('The name field is empty. Please enter a name.');
    return;
  }
  if (doesNameExist(newItemName)) {
    alert('A folder or file with this name already exists. Please enter a unique name.');
    return;
  }
  addItemToTree(newItem);
  const response = await updateJsonFile();

  if (response.ok) {
    const updatedData = await response.json();
    fileTreeData = updatedData;  // Update the client-side data
  }
  document.querySelector('.addConfirm').remove();
}

function doesNameExist(name) {
  if (selectedElement) {
    const siblings = selectedElement.nextElementSibling.children;
    for (let i = 0; i < siblings.length; i++) {
      if (siblings[i].firstElementChild.getAttribute('data-name').toLowerCase() === name.toLowerCase()) {
        return true;
      }
    }
  }
  return false;
}

async function updateJsonFile() {
  let dataToSend = {
    author: cur_user,
    updatedJSON: fileTreeData,
    selItemName: selectedItemName,
    selItemType: selectedItemType,
    selItemContent: selectedItemContent,
    itemName: newItemName,
    itemType: newItemType,
    changeLocation: itemPath,
    parentName: parentItemName,
    fileList: affectedFileList,
    changeList: changeFileList,
    allFiles: allFileList,
    parentLocation: parentPath, 
    action: actionType,
    moveSourcePath: sourcePath,
    moveDestinationPath: destinationPath
  };

  const response = await fetch('/update_json', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(dataToSend)
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  const data = await response.json();
  
  fileTreeData = data;
  fileTreeElement.innerHTML = '';
  createFileTree(fileTreeData, fileTreeElement, true, newItemName);
  const newItemElement = fileTreeElement.querySelector(`div[data-name="${newItemName}"]`);
  if (newItemElement) {
    newItemElement.click();
    openPathToItem(itemPath);
  }
  if (actionType === 'delete') {
    cancelAction();
  }
}

function getAllFiles(node) {
  if (node.type === 'file') {
    allFileList.push(node.content);
  } else if (node.children) {
    node.children.forEach(getAllFiles);
  }
}

// Existing function to check children
function checkChildren(node) {
  if (node.type === 'file') {
    affectedFileList.push(node.content);
  } else if (node.children) {
    node.children.forEach(checkChildren);
  }
}

function checkSelectedChildren(node) {
  if (node.type === 'file') {
    changeFileList.push(node.content);
  } else if (node.children) {
    node.children.forEach(checkSelectedChildren);
  }
}


function addItemToTree(item) {
  actionType = 'add';
  sourcePath = '';
  destinationPath = '';
  const listItem = document.createElement('li');
  listItem.innerHTML = `<div class="${item.type}" data-name="${item.name}">${item.name}</div>`;
  selectedItem.appendChild(listItem);
  itemPath = getItemPath(selectedElement);
  const pathArray = itemPath.split(' > ');
  parentItemName = pathArray[pathArray.length - 1]; // Added this line
  parentPath = pathArray.slice(0, pathArray.length - 1).join(' > '); // Added this line
  let currentNode = fileTreeData;
  for (let i = 0; i < pathArray.length; i++) {
    const child = currentNode.children.find(node => node.name === pathArray[i]);
    if (child) {
      currentNode = child;
    }
  }
  currentNode.children.push(item);
  affectedFileList.length = 0;
  changeFileList.length = 0;
  checkChildren(currentNode);
  checkSelectedChildren(currentNode);
  allFileList = [];
  getAllFiles(fileTreeData);
}

function getParentItem(item) {
  const listItem = document.createElement('li');
  listItem.innerHTML = `<div class="${item.type}" data-name="${item.name}">${item.name}</div>`;
  selectedItem.appendChild(listItem);
  itemPath = getItemPath(selectedElement);
}

async function deleteItem() {
  actionType = 'delete';
  newItemName = 'None';
  newItemType = 'None'
  sourcePath = '';
  destinationPath = '';
  itemPath = getItemPath(selectedElement);
  pathArray = itemPath.split(' > ');
  parentItemName = pathArray[pathArray.length - 2]; // Get parent's name
  parentPath = pathArray.slice(0, pathArray.length - 1).join(' > '); // Get parent's path
  let currentNode = fileTreeData;
  for (let i = 0; i < pathArray.length; i++) {
    const child = currentNode.children.find(node => node.name === pathArray[i]);
    if (child) {
      currentNode = child;
    }
  }
  let parentNode = fileTreeData;
  for (let i = 0; i < parentPath.length; i++) {
    const child = parentNode.children.find(node => node.name === parentPath[i]);
    if (child) {
      parentNode = child;
    }
  }
  affectedFileList.length = 0;
  changeFileList.length = 0;
  checkChildren(parentNode);
  checkSelectedChildren(currentNode);
  allFileList = [];
  getAllFiles(fileTreeData);
  deleteItemFromTree(itemPath);
  document.querySelector('.deleteConfirm').remove();

  const response = await updateJsonFile();

  if (response.ok) {
    const updatedData = await response.json();
    fileTreeData = updatedData;  // Update the client-side data
  }  
}

function deleteItemFromTree(path) {
  const pathArray = path.split(' > ');
  let currentNode = fileTreeData;
  let parent = null;

  for (let i = 0; i < pathArray.length; i++) {
    const childIndex = currentNode.children.findIndex(node => node.name === pathArray[i]);
    if (childIndex !== -1) {
      parent = currentNode;
      currentNode = currentNode.children[childIndex];
      if (i === pathArray.length - 1) {
        parent.children.splice(childIndex, 1);
      }
    }
  }
}

function openPathToItem(path) {
  const pathArray = path.split(' > ');
  let currentElement = fileTreeElement;

  pathArray.forEach(name => {
    const childElement = currentElement.querySelector(`div[data-name="${name}"]`);
    if (childElement) {
      if (childElement.classList.contains('folder')) {
        childElement.classList.add('open');
        childElement.nextElementSibling.style.display = 'block';
      }
      currentElement = childElement.nextElementSibling;
    }
  });
}

function findFileData(node, filePath, path) {
  const currentPath = path ? `${path} > ${node.name}` : node.name;
  if (currentPath === filePath && node.type === 'file') {
    return node;
  }
  if (node.children) {
    for (const child of node.children) {
      const result = findFileData(child, filePath, currentPath);
      if (result) {
        return result;
      }
    }
  }
  return null;
}

function getItemPath(element) {
  let path = element.getAttribute('data-name');
  let parentElement = element.parentElement.parentElement.previousElementSibling;

  while (parentElement) {
    path = `${parentElement.getAttribute('data-name')} > ${path}`;
    parentElement = parentElement.parentElement.parentElement.previousElementSibling;
  }
  return path;
}

let idRef = {};
let categoryName;
let entryName;
let entryID;

function displayTextInRightPanel(content, file_id) {
  const editorContainer = document.getElementById('editorContainer');
  editorContainer.innerHTML = '<div id="right_stuff"><div id="editor"></div></div>';
  var icons = Quill.import('ui/icons');

  icons['ql-header ql-picker'] = '<svg viewBox="3 3 12 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon class="ql-stroke" points="7 11 9 13 11 11 7 11"></polygon><polygon class="ql-stroke" points="7 7 9 5 11 7 7 7"></polygon></svg>';
  icons['bold'] = '<svg viewBox="3 3 12 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path class="ql-stroke" d="M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z"></path><path class="ql-stroke" d="M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z"></path></svg>';
  icons['italic'] = '<svg viewBox="3 3 12 12" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"></line><line class="ql-stroke" x1="7" x2="13" y1="4" y2="4"></line><line class="ql-stroke" x1="5" x2="11" y1="14" y2="14"></line><line class="ql-stroke" x1="8" x2="10" y1="14" y2="4"></line></svg>';
  icons['underline'] = '<svg viewBox="2 2 15 15" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path class="ql-stroke" d="M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3"></path><rect class="ql-fill" height="0.3" rx="0.5" ry="0.5" width="12" x="3" y="15.5"></rect></svg>';
  icons['link'] = '<svg class="my-custom-icon" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"><circle cx="100" cy="100" r="100"/></svg>';
  icons['list']['ordered'] = '<svg viewBox="0 1 10 10" fill="none" stroke="currentColor" stroke-width="0.2" stroke-linecap="round" stroke-linejoin="round"><line class="ql-stroke" x1="7" x2="15" y1="4" y2="4"></line><line class="ql-stroke" x1="7" x2="15" y1="9" y2="9"></line><line class="ql-stroke" x1="7" x2="15" y1="14" y2="14"></line><line class="ql-stroke ql-thin" x1="2.5" x2="4.5" y1="5.5" y2="5.5"></line><path class="ql-fill" d="M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z"></path><path class="ql-stroke ql-thin" d="M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156"></path><path class="ql-stroke ql-thin" d="M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109"></path></svg>';
  icons['list']['bullet'] = '<svg viewBox="0 6 10 10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line class="ql-stroke" x1="6" x2="15" y1="4" y2="4"></line><line class="ql-stroke" x1="6" x2="15" y1="9" y2="9"></line><line class="ql-stroke" x1="6" x2="15" y1="14" y2="14"></line><line class="ql-stroke" x1="3" x2="3" y1="4" y2="4"></line><line class="ql-stroke" x1="3" x2="3" y1="9" y2="9"></line><line class="ql-stroke" x1="3" x2="3" y1="14" y2="14"></line></svg>';
  icons['clean'] = '<svg viewBox="1.4 1.4 15 15" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line class="ql-stroke" x1="5" x2="13" y1="3" y2="3"></line><line class="ql-stroke" x1="6" x2="9.35" y1="12" y2="3"></line><line class="ql-stroke" x1="11" x2="15" y1="11" y2="15"></line><line class="ql-stroke" x1="15" x2="11" y1="11" y2="15"></line><rect class="ql-fill" height="1" rx="0.5" ry="0.5" width="7" x="2" y="14"></rect></svg>';

  var quill = new Quill('#editor', {
    modules: {
      toolbar: '#toolbar'
    },
    theme: 'snow'
  });


  let quillContent = document.querySelector('.ql-editor');
  quillContent.style.backgroundColor = '#383838';
  quillContent.style.color = '#00dd00';
  quillContent.style.borderColor = '#ffffff';
  quillContent.style.fontSize = '2em';

  let pickerElement = document.querySelector('.ql-snow .ql-picker:not(.ql-color-picker):not(.ql-icon-picker) svg'); 
  pickerElement.style.position = 'absolute';
  pickerElement.style.marginTop = '-10.5px';
  pickerElement.style.right = '85px';
  pickerElement.style.top = '36%';
  pickerElement.style.width = '30px';

  quill.clipboard.dangerouslyPasteHTML(content);
  
  const saveBtn = document.getElementById('saveBtn');

  saveBtn.addEventListener('click', function() {
    const editorContent = quill.root.innerHTML;

    fetch('/save_content', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ 
        content: editorContent,
        f_id: file_id
      })
    });
  });

  document.querySelector('#custom-link-button').addEventListener('click', function() {
    if (document.getElementById("linkDropdownDiv")) {
      console.log('red');
    } else {
      console.log('blue');
    }

    let categorySearchInput = document.createElement('input');
    categorySearchInput.type = 'text';
    categorySearchInput.id = 'categorySearchInput';
    categorySearchInput.className = 'custom-drop-filter';
    categorySearchInput.placeholder = 'Category...';
    categorySearchInput.style.display = 'None';

    let linkDropdownDiv = document.querySelector('#linkDropdownDiv');
    linkDropdownDiv.appendChild(categorySearchInput);

    // Create a div for the categories
    let categoryDiv = document.createElement('div');
    categoryDiv.id = 'categoryDiv';
    categoryDiv.className = 'custom-dropdown'; 
    categoryDiv.style.display = 'none';

    // Create a search input field
    let entrySearchInput = document.createElement('input');
    entrySearchInput.type = 'text';
    entrySearchInput.id = 'entrySearchInput';
    entrySearchInput.className = 'custom-drop-filter';
    entrySearchInput.placeholder = 'Search...';
    entrySearchInput.style.display = 'none'; // Initially hidden

    // Create a left arrow icon
    let leftArrow = document.createElement('span');
    leftArrow.className = 'custom-drop-buttons';
    leftArrow.textContent = '←';
    leftArrow.style.display = 'none'; // Initially hidden

    // Append the left arrow and the search input field to your HTML
    linkDropdownDiv.appendChild(entrySearchInput);
    linkDropdownDiv.appendChild(leftArrow);
    

    // Create a div for the entries
    let entryDiv = document.createElement('div');
    entryDiv.id = 'entryDiv';
    entryDiv.className = 'custom-dropdown';
    entryDiv.style.display = 'none';

    
    // Append the div to your HTML
    linkDropdownDiv.appendChild(entryDiv);

    // Append the div to your HTML
    linkDropdownDiv.appendChild(categoryDiv);
    fetch('/get_categories')
      .then(response => response.json())
      .then(categories => {
        // Populate the div with the categories
        categoryDiv.innerHTML = ''; // Clear previous categories
        Object.keys(categories).forEach(categoryId => {
          let div = document.createElement('div');
          div.textContent = categories[categoryId];
          div.addEventListener('click', function() {
            categoryName = div.innerHTML;
            // Replace the dropdown with the search input field
            categorySearchInput.style.display = 'none';
            categoryDiv.style.display = 'none';
            leftArrow.style.display = '';
            entrySearchInput.style.display = '';
            entryDiv.style.display = '';
            fetch('/get_category/' + div.innerHTML)
              .then(response => response.json())
              .then(data => {
                // Populate the div with the entries
                entryDiv.innerHTML = ''; // Clear previous entries
                Object.keys(data).forEach(entryId => {
                  let div = document.createElement('div');
                  div.textContent = data[entryId];
                  idRef[data[entryId]] = entryId;
                  div.addEventListener('click', function() {
                    entryName = div.innerHTML;
                    entryID = idRef[entryName];
                    send_selection();
                  });
                  entryDiv.appendChild(div);
                });
              });                
            });
            categoryDiv.appendChild(div);
          });
          categorySearchInput.style.display = '';
          categoryDiv.style.display = '';
        });

        // Add an event listener to the search field
        categorySearchInput.addEventListener('input', function() {
          let filter = categorySearchInput.value.toUpperCase();
          let divs = categoryDiv.getElementsByTagName('div');
          for (let i = 0; i < divs.length; i++) {
            let txtValue = divs[i].textContent;
            if (txtValue.toUpperCase().indexOf(filter) > -1) {
              divs[i].style.display = '';
            } else {
              divs[i].style.display = 'none';
            }
          }
        });

        // Add an event listener to the left arrow
        leftArrow.addEventListener('click', function() {
          // Replace the search input field with the dropdown
          categorySearchInput.style.display = '';
          categoryDiv.style.display = '';
          leftArrow.style.display = 'none';
          entrySearchInput.style.display = 'none';
          entryDiv.style.display = 'none'; // Hide the div
        });

        // Add an event listener to the search field
        entrySearchInput.addEventListener('input', function() {
          let filter = entrySearchInput.value.toUpperCase();
          let divs = entryDiv.getElementsByTagName('div');
          for (let i = 0; i < divs.length; i++) {
            let txtValue = divs[i].textContent;
            if (txtValue.toUpperCase().indexOf(filter) > -1) {
              divs[i].style.display = '';
            } else {
              divs[i].style.display = 'none';
            }
          }
          entryDiv.style.display = ''; // Show the div when typing
        });
  });

  async function send_selection() {
    let dataToSend = {
      entryNameK: entryName,
      categoryNameK: categoryName,
      entryIDK: entryID
    };

    const response = await fetch('/get_summary', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(dataToSend)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    console.log(data);
  }

  quill.on('text-change', function(delta, oldDelta, source) {
    if (source == 'user') {
      let ops = delta.ops;
      ops.forEach(op => {
        if (op.insert && op.insert.link) {
          fetch(op.insert.link)
            .then(response => response.json())
            .then(data => alert(JSON.stringify(data)));
        }
      });
    }
  });  
}
    const separator = document.getElementById('separator');
    const leftPanel = document.getElementById('leftPanel');
    const rightPanel = document.getElementById('rightPanel');
    let isResizing = false;
    let initialMouseX;
    separator.addEventListener('mousedown', startResize);
    separator.addEventListener('touchstart', startResize);
    function startResize(event) {
      isResizing = true;
      initialMouseX = event.clientX || event.touches[0].clientX; 
      document.body.style.userSelect = 'none'; 
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('touchmove', handleMouseMove, { passive: false }); 
      document.addEventListener('mouseup', stopResize);
      document.addEventListener('touchend', stopResize);
    }

    function handleMouseMove(event) {
      if (isResizing) {
        event.preventDefault(); 
        const clientX = event.clientX || event.touches[0].clientX;
        const dx = clientX - initialMouseX;
        const newLeftWidth = parseInt(window.getComputedStyle(leftPanel).width) + dx;
        const newRightWidth = parseInt(window.getComputedStyle(rightPanel).width) - dx;

        leftPanel.style.width = newLeftWidth + 'px';
        rightPanel.style.width = newRightWidth + 'px';

        initialMouseX = clientX;
      }
    }
    
    function stopResize() {
      isResizing = false;
      document.body.style.userSelect = ''; 
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('touchmove', handleMouseMove);
    }
</script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>

{% endblock %}
{% extends "base.html" %}

{% block content %}

<div id="container">
  <div id="leftPanel">
    <button id="toggleBtn" onclick="toggleFileTreeSearch()">Search</button>
    <div id="fileTreeContainer">
      <div id="fileTree" class="root-folder"></div>
    </div>
    <div id="searchContainer">
      <input type="text" id="searchInput" placeholder="Search...">
      <button onclick="runSearch()">Search</button>
      <ul id="searchResults" onclick="handleSearchResultClick(event)"></ul>
    </div>
  </div>

  <div id="separator"></div>

  <div id="rightPanel">
    <!-- Content for the right panel goes here -->
  </div>
</div>

<script>
const fileTreeData = JSON.parse('{{ cabinet | tojson | safe }}');

function createFileTree(node, parentElement, isFirstLayer = true) {
  const listItem = document.createElement('li');
  listItem.innerHTML = `<div class="${node.type === 'folder' ? 'folder' : 'file'}" data-name="${node.name}">${node.name}</div>`;

  if (node.children) {
    const childList = document.createElement('ul');
    if (!isFirstLayer) {
      childList.style.display = 'none';
    }
    node.children.forEach(childNode => createFileTree(childNode, childList, false));
    listItem.appendChild(childList);

    if (node.type === 'folder') {
      const folderElement = listItem.querySelector('.folder');
      folderElement.addEventListener('click', () => {
        // Check if the folder is a top-level folder
        if (!isFirstLayer) {
          childList.style.display = childList.style.display === 'none' ? 'block' : 'none';
          folderElement.classList.toggle('open');
        }
      });

      // Open the folder if it's in the first layer
      if (isFirstLayer) {
        childList.style.display = 'block';
        folderElement.classList.add('open');
      }
    }
  }

  parentElement.appendChild(listItem);
}

const fileTreeElement = document.getElementById('fileTree');
createFileTree(fileTreeData, fileTreeElement);

function toggleFileTreeSearch() {
  const fileTreeContainer = document.getElementById('fileTreeContainer');
  const searchContainer = document.getElementById('searchContainer');
  const toggleBtn = document.getElementById('toggleBtn');

  if (fileTreeContainer.style.display !== 'none') {
    fileTreeContainer.style.display = 'none';
    searchContainer.style.display = 'block';
    toggleBtn.textContent = 'File Tree';
  } else {
    fileTreeContainer.style.display = 'block';
    searchContainer.style.display = 'none';
    toggleBtn.textContent = 'Search';
  }
}

function runSearch() {
  const searchInput = document.getElementById('searchInput').value.toLowerCase();
  const searchResults = document.getElementById('searchResults');
  searchResults.innerHTML = '';

  if (searchInput.length === 0) {
    return;
  }

  // Function to perform a case-insensitive search
  function searchInTree(node, path) {
    const matches = [];
    const nodeName = node.name.toLowerCase();

    if (nodeName.includes(searchInput)) {
      matches.push({ path, confidence: 5 });
    }

    if (node.children) {
      node.children.forEach((child, index) => {
        const childPath = path ? `${path} > ${child.name}` : child.name;
        matches.push(...searchInTree(child, childPath));
      });
    }

    return matches;
  }

  const searchResultsData = searchInTree(fileTreeData, '');
  const sortedResults = searchResultsData.sort((a, b) => b.confidence - a.confidence);

  sortedResults.slice(0, 5).forEach(result => {
    const listItem = document.createElement('li');
    listItem.textContent = result.path;
    listItem.addEventListener('click', () => handleSearchResultClick(result.path));
    searchResults.appendChild(listItem);
  });
}

function handleSearchResultClick(path) {
  const fileTreeContainer = document.getElementById('fileTreeContainer');
  const searchContainer = document.getElementById('searchContainer');
  const toggleBtn = document.getElementById('toggleBtn');

  const pathArray = path.split(' > ');
  const lastNodeName = pathArray.pop(); 

  let currentNode = fileTreeData;
  let currentElement = fileTreeElement;


  const allFolders = fileTreeElement.querySelectorAll('.folder');
  allFolders.forEach(folder => {
    
    if (folder.parentElement.parentElement.id !== 'fileTree') {
      folder.nextElementSibling.style.display = 'none';
      folder.classList.remove('open');
    }
  });

  
  pathArray.forEach(name => {
    const child = currentNode.children.find(node => node.name === name);
    if (child) {
      currentNode = child;
      const element = currentElement.querySelector(`[data-name="${currentNode.name}"]`);
      if (element) {
        
        if (currentNode.type === 'folder' && !element.classList.contains('open')) {
          element.classList.add('open');
          element.nextElementSibling.style.display = 'block';
        }

        currentElement = element.nextElementSibling;
      }
    }
  });

  const lastElement = currentElement.querySelector(`[data-name="${lastNodeName}"]`);
  if (lastElement) {
    lastElement.classList.add('highlight');
  }

  const element = currentElement.querySelector(`[data-name="${lastNodeName}"]`);
  if (element) {
    const container = fileTreeContainer.querySelector('ul');
    container.scrollTop = element.offsetTop - container.offsetTop;
  }

  fileTreeContainer.style.display = 'block';
  searchContainer.style.display = 'none';
  toggleBtn.textContent = 'Search';
}

fileTreeElement.addEventListener('click', (event) => {
  const target = event.target;
  const fileTypeElement = target.closest('.file');

  if (fileTypeElement) {
    const fileName = fileTypeElement.getAttribute('data-name');
    const filePath = getFilePath(fileTypeElement);
    const fileData = findFileData(fileTreeData, filePath, '');

    if (fileData && fileData.content) {
      // Make an AJAX request to the Flask server with the file content
      fetch('/process_file_content', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ content: fileData.content })
      })
      .then(response => response.json())
      .then(data => {
        // Display the processed content in the right panel
        displayTextInRightPanel(data.processed_content);
      });
    }
  }
});

function findFileData(node, filePath, path) {
  const currentPath = path ? `${path} > ${node.name}` : node.name;

  if (currentPath === filePath && node.type === 'file') {
    return node;
  }

  if (node.children) {
    for (const child of node.children) {
      const result = findFileData(child, filePath, currentPath);
      if (result) {
        return result;
      }
    }
  }

  return null;
}

function getFilePath(element) {
  let path = element.getAttribute('data-name');
  let parentElement = element.parentElement.parentElement.previousElementSibling;

  while (parentElement) {
    path = `${parentElement.getAttribute('data-name')} > ${path}`;
    parentElement = parentElement.parentElement.parentElement.previousElementSibling;
  }

  return path;
}

function displayTextInRightPanel(content) {
  const rightPanel = document.getElementById('rightPanel');
  rightPanel.textContent = content;
}

    // Add code for handling separator dragging
    const separator = document.getElementById('separator');
    const leftPanel = document.getElementById('leftPanel');
    const rightPanel = document.getElementById('rightPanel');
    let isResizing = false;
    let initialMouseX;

    separator.addEventListener('mousedown', startResize);
    separator.addEventListener('touchstart', startResize);

    function startResize(event) {
      isResizing = true;
      initialMouseX = event.clientX || event.touches[0].clientX; // Calculate initial position relative to the cursor's position
      document.body.style.userSelect = 'none'; // Disable text selection
      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('touchmove', handleMouseMove, { passive: false }); // Add passive: false to the options
      document.addEventListener('mouseup', stopResize);
      document.addEventListener('touchend', stopResize);
    }

    function handleMouseMove(event) {
      if (isResizing) {
        event.preventDefault(); // Add this line to prevent scrolling
        const clientX = event.clientX || event.touches[0].clientX;
        const dx = clientX - initialMouseX;
        const newLeftWidth = parseInt(window.getComputedStyle(leftPanel).width) + dx;
        const newRightWidth = parseInt(window.getComputedStyle(rightPanel).width) - dx;

        leftPanel.style.width = newLeftWidth + 'px';
        rightPanel.style.width = newRightWidth + 'px';

        initialMouseX = clientX;
      }
    }

    function stopResize() {
      isResizing = false;
      document.body.style.userSelect = ''; // Enable text selection
      document.removeEventListener('mousemove', handleMouseMove);
      document.removeEventListener('touchmove', handleMouseMove);
    }
    
</script>

{% endblock %}